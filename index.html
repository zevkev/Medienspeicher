<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Defender ‚Äî Fabrik-Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');
    :root{
      --player-actual-size:80px;
      --player-visual-scale:0.85;
      --ring-width:8px;
    }
    body{background:#0b1220;color:#fff;font-family:'Chakra Petch',sans-serif}
    .liquid-glass{backdrop-filter: blur(8px) saturate(140%); -webkit-backdrop-filter: blur(8px) saturate(140%); background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); border-radius:12px; border:1px solid rgba(255,255,255,0.04); box-shadow: 0 6px 22px rgba(0,0,0,0.6);}
    .futura{font-family:'Chakra Petch',sans-serif}
    .btn{padding:.5rem .75rem;border-radius:.6rem;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
    #gameCanvas{display:block;border-radius:12px}
    #player{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:var(--player-actual-size);pointer-events:none;z-index:30}
    @keyframes pulse-glow{0%,100%{transform:translate(-50%,-50%) scale(1);text-shadow:0 0 6px rgba(255,255,255,0.6)}50%{transform:translate(-50%,-50%) scale(1.02);text-shadow:0 0 12px rgba(255,255,255,0.9)}}
    #player{animation:pulse-glow 2.6s infinite ease-in-out}
    #playerHealthCircle{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:none}
    .production-animation{position:absolute;font-weight:700;pointer-events:none;animation:pop-up 0.9s cubic-bezier(.2,.8,.2,1);opacity:1}
    @keyframes pop-up{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-48px);opacity:0}}
    .building-popup{position:absolute;transform:translate(-50%,-120%);min-width:180px;z-index:60;padding:.6rem;border-radius:.6rem;box-shadow:0 8px 30px rgba(0,0,0,0.6);background:linear-gradient(180deg, rgba(12,16,30,0.95), rgba(6,8,16,0.95));border:1px solid rgba(255,255,255,0.04)}
    .building-badge{padding:.25rem .45rem;border-radius:.5rem;background:rgba(255,255,255,0.03);font-weight:700}
    .small-muted{font-size:12px;color:#bfc7d6}
    .glow { filter: drop-shadow(0 6px 18px rgba(0,0,0,0.6)); }
    .smoke{position:absolute;pointer-events:none;opacity:.9;font-size:14px}
    /* upgrade flash */
    .upgrade-flash{animation:upgradeFlash .6s ease-out}
    @keyframes upgradeFlash{0%{transform:scale(1);opacity:1}50%{transform:scale(1.08);opacity:1}100%{transform:scale(1);opacity:1}}
  </style>
</head>
<body class="futura min-h-screen flex items-center justify-center p-4">

  <div id="app" class="w-full max-w-6xl">
    <!-- TOP UI -->
    <div class="liquid-glass p-3 mb-3 flex items-center justify-between">
      <div>
        <div class="text-sm">Views <span id="viewsCount" class="font-bold">0</span></div>
        <div id="videoTitle" class="small-muted text-xs">Willkommen</div>
      </div>

      <div class="text-center">
        <div class="text-sm">Daten: <span id="dataCount" class="font-bold">0</span> üíø</div>
        <div class="w-72 h-2 bg-gray-700 rounded-full mt-2 overflow-hidden">
          <div id="videoBar" class="h-2 bg-gradient-to-r from-purple-400 to-pink-500" style="width:0%"></div>
        </div>
        <div class="small-muted text-xs mt-1">Produktion</div>
      </div>

      <div class="text-right">
        <div class="text-sm">Bugs: <span id="currentBugs">0</span>/<span id="maxBugs">5</span></div>
        <div class="text-sm">Gesamt: +<span id="prodRate">0</span> üíø/s</div>
      </div>
    </div>

    <!-- GAME AREA -->
    <div id="gameContainer" class="relative aspect-video rounded-xl overflow-hidden bg-gradient-to-br from-[#07101b] to-[#0e1624] shadow-2xl">
      <canvas id="gameCanvas"></canvas>
      <div id="player">üíæ</div>
      <svg id="playerHealthCircle" viewBox="0 0 110 110" style="width:100px;height:100px;">
        <circle id="hpRing" cx="55" cy="55" r="50" stroke="#34D399" fill="none" stroke-width="8" transform="rotate(-90 55 55)"></circle>
      </svg>
      <div id="productionAnimContainer" style="position:absolute;inset:0;pointer-events:none;z-index:55"></div>

      <!-- Building popup (variant A) -->
      <div id="buildingPopup" class="building-popup hidden">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <div id="popupEmoji" style="font-size:22px">üè≠</div>
            <div>
              <div id="popupName" class="font-bold">Data Factory</div>
              <div id="popupDesc" class="small-muted text-xs">Generiert Daten pro Sekunde</div>
            </div>
          </div>
          <div id="popupLevel" class="building-badge">Lv. 0</div>
        </div>
        <div class="mb-2">
          Produktion: <span id="popupProd">+0</span> üíø/s
        </div>
        <div class="mb-3 small-muted text-xs" id="popupMore">Upgrade f√ºr mehr Produktion.</div>
        <div class="flex gap-2">
          <button id="popupUpgradeBtn" class="btn grow">Upgrade (<span id="popupCost">0</span> üíø)</button>
          <button id="popupCloseBtn" class="btn">Schlie√üen</button>
        </div>
      </div>

      <!-- global small hint -->
      <div style="position:absolute;right:14px;bottom:12px;z-index:60">
        <div class="liquid-glass p-2 text-xs small-muted">Klicke auf ein Fabrik-Icon unten, um Details & Upgrade</div>
      </div>

    </div>

    <!-- Shop modal (full upgrade list) -->
    <div id="modalOverlay" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-60 z-70">
      <div class="liquid-glass p-4 w-full max-w-xl">
        <div class="flex justify-between items-center mb-3">
          <h3 class="font-bold text-lg">Upgrades</h3>
          <button id="closeModal" class="btn">Schlie√üen</button>
        </div>
        <div id="upgradeList" class="grid gap-3 max-h-96 overflow-auto"></div>
      </div>
    </div>
  </div>

<script>
/* ------------------------------------------------------------------
   Vollst√§ndige Spiel-Logik (eine Datei)
   - Buildings produce continuously (per-frame)
   - Clickable building popup (Variant A)
   - All upgrades concrete & consistent
   - Balancing adjusted
   - Visual/animation improvements (pulses, smoke, upgrade flash)
   - Buildings cannot be destroyed (bugs target player only)
--------------------------------------------------------------------*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const productionAnimContainer = document.getElementById('productionAnimContainer');
const buildingPopup = document.getElementById('buildingPopup');

const viewsCountEl = document.getElementById('viewsCount');
const dataCountEl = document.getElementById('dataCount');
const videoBarEl = document.getElementById('videoBar');
const currentBugsEl = document.getElementById('currentBugs');
const maxBugsEl = document.getElementById('maxBugs');
const prodRateEl = document.getElementById('prodRate');
const videoTitleEl = document.getElementById('videoTitle');

let lastTimestamp = performance.now();
let frameCount = 0;

const PLAYER = { x: 0, y: 0 };
const PLAYER_SIZE_PERCENTAGE = 0.15;
let bugs = [];
let projectiles = [];
let particles = [];
let smokeParticles = [];
let productionPopups = [];
let isPaused = false;
let isGameOver = false;

/* ---- Building definitions & upgrades ----
   Each production building has an upgrade entry that controls its level, baseCost, effect(level) -> production per sec
*/
const PRODUCTION_BUILDINGS = [
  { key:'dataFactory', name:'Datenfabrik', emoji:'üè≠', color:'#facc15', baseCost:1200 },
  { key:'serverFarm', name:'Server-Farm', emoji:'üíΩ', color:'#60a5fa', baseCost:6000 },
  { key:'quantumCache', name:'Quanten-Cache', emoji:'üíé', color:'#a78bfa', baseCost:20000 },
  { key:'neuralNetCluster', name:'Neural Cluster', emoji:'üß†', color:'#818cf8', baseCost:90000 },
  { key:'globalCDN', name:'Global CDN', emoji:'üåê', color:'#34d399', baseCost:350000 },
];

const INITIAL_STATE = {
  views:0,
  data: 2500, // starting data so player can buy first building quickly for testing
  playerHP:100,
  maxHP:100,
  videoProgress:0,
  videoLevel:0,
  gameTime:0,
  lastBugSpawn:0,
  bugSpawnInterval:3000,
  maxBugs:5,

  // upgrades object: includes production buildings and utility upgrades
  upgrades: {
    // production buildings: levels start at 0 (not yet built)
    dataFactory: { level:0, baseCost:1200, maxLevel:100, desc:'Kleine Datenfabrik. Stabile Produktion.' , effect: l => 12 + l*6 },     // 12 + 6*l
    serverFarm: { level:0, baseCost:6000, maxLevel:100, desc:'Mehrere Rack-Server. Gro√üer Durchsatz.' , effect: l => 90 + l*60 },   // 90 + 60*l
    quantumCache: { level:0, baseCost:20000, maxLevel:100, desc:'Quantenoptimierte Zwischenspeicherung.' , effect: l => 600 + l*300 },
    neuralNetCluster: { level:0, baseCost:90000, maxLevel:100, desc:'Trainiertes Netz generiert Daten.' , effect: l => 3500 + l*1600 },
    globalCDN: { level:0, baseCost:350000, maxLevel:100, desc:'Global verteiltes CDN ‚Äî massiv.' , effect: l => 18000 + l*8500 },

    // utility upgrades
    prodSpeed: { level:0, baseCost:120, maxLevel:100, desc:'Beschleunigt Videofortschritt (multiplikativ).', effect: l => 1 + l*0.25 }, // 1x -> large
    moreData: { level:0, baseCost:60, maxLevel:100, desc:'Erh√∂ht Daten-Drops (Multiplikator L+1).', effect: l => 1 + l }, // x1..x101
    attackDamage: { level:0, baseCost:120, maxLevel:100, desc:'Erh√∂ht deine Projektil-Schaden.', effect: l => 1 + l }, // 1..101
    goldenDropChance: { level:0, baseCost:420, maxLevel:100, desc:'Chance auf goldene CDs (10x Daten).', effect: l => Math.min(0.99, 0.08 + l*0.0092) }, // ~8% -> ~1.0
    viewBoost: { level:0, baseCost:240, maxLevel:100, desc:'Views pro Video erh√∂hen.', effect: l => 1 + l*0.18 },
    attackSpeed: { level:0, baseCost:140, maxLevel:100, desc:'Reduziert Cooldown des manuellen Schusses.', effect: l => Math.max(0.05, 0.45 - l*0.004) }, // 0.45 -> 0.05
    multiShot: { level:0, baseCost:360, maxLevel:20, desc:'Schie√üt mehrere Projektile gleichzeitig.', effect: l => 1 + Math.floor(l/2) }, // 0->1 ; 2 level -> +1 shot
    hpRegen: { level:0, baseCost:220, maxLevel:100, desc:'Regen pro Sekunde (klein).', effect: l => 0.05 + l*0.06 }, // 0.05 -> significant
    floppyProtector: { level:0, baseCost:180, maxLevel:500, desc:'Sch√ºtzt dich automatisch mit Drohnen (Feuer alle 5s).', effect: l => l }
  },

  cooldowns: { shot:0, protectorShot:5000 },

  // buildings[] will be the visible slots; we treat a building as "visible" when its upgrade level > 0
  buildings: [], // each entry: { key, xIndex (set at draw), accumulator }
};

/* State */
let state = JSON.parse(JSON.stringify(INITIAL_STATE));

/* --- Basic audio (simple oscillator) --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioCtx.createGain();
masterGain.gain.value = 0.6;
masterGain.connect(audioCtx.destination);

function playSine(freq, dur=0.07, vol=0.6){
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = freq;
  g.gain.value = vol * 0.6;
  o.connect(g); g.connect(masterGain);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
  o.stop(audioCtx.currentTime + dur + 0.02);
}

/* --- Persistence --- */
function save(){
  const saveObj = {
    views: state.views, data: state.data, playerHP: state.playerHP, videoProgress: state.videoProgress, videoLevel: state.videoLevel,
    upgrades: Object.fromEntries(Object.entries(state.upgrades).map(([k,v])=>[k,{level:v.level}])),
    buildings: state.buildings
  };
  localStorage.setItem('codeDefender_v2', JSON.stringify(saveObj));
}
function load(){
  const s = localStorage.getItem('codeDefender_v2');
  if (!s) return;
  try{
    const parsed = JSON.parse(s);
    if (parsed.views !== undefined) state.views = parsed.views;
    if (parsed.data !== undefined) state.data = parsed.data;
    if (parsed.playerHP !== undefined) state.playerHP = parsed.playerHP;
    if (parsed.videoProgress !== undefined) state.videoProgress = parsed.videoProgress;
    if (parsed.videoLevel !== undefined) state.videoLevel = parsed.videoLevel;
    if (parsed.upgrades){
      for (let k in parsed.upgrades){
        if (state.upgrades[k] && parsed.upgrades[k].level !== undefined){
          state.upgrades[k].level = parsed.upgrades[k].level;
        }
      }
    }
    if (Array.isArray(parsed.buildings)) state.buildings = parsed.buildings.map(b => ({...b, accumulator: b.accumulator||0}));
  }catch(e){ console.warn('Load failed',e); }
}
load();

/* Ensure buildings array matches upgrades (if there are levels >0 but no building slot) */
function syncBuildingsFromUpgrades(){
  PRODUCTION_BUILDINGS.forEach((proto)=>{
    const up = state.upgrades[proto.key];
    if (up && up.level > 0){
      const exists = state.buildings.find(b=>b.key===proto.key);
      if(!exists) state.buildings.push({ key:proto.key, xIndex: state.buildings.length, accumulator:0 });
    }
  });
}
syncBuildingsFromUpgrades();

/* --- Canvas sizing & player pos --- */
function resize(){
  const rect = document.getElementById('gameContainer').getBoundingClientRect();
  canvas.width = Math.floor(rect.width);
  canvas.height = Math.floor(rect.height);
  PLAYER.x = canvas.width/2;
  PLAYER.y = canvas.height/2;
  const ringReference = Math.min(canvas.width, canvas.height) * PLAYER_SIZE_PERCENTAGE;
  document.documentElement.style.setProperty('--player-actual-size', ringReference + 'px');
}
window.addEventListener('resize', resize);
resize();

/* ------------------------------
   Utility: cost formula & buy
   ------------------------------ */
function costFor(key, level){
  const up = state.upgrades[key];
  if (!up) return Infinity;
  // Special: floppyProtector has strong exponential growth
  if (key==='floppyProtector'){
    return Math.floor(up.baseCost * Math.pow(2.4, level));
  }
  // Production buildings get slightly higher multiplier
  let base = up.baseCost || (PRODUCTION_BUILDINGS.find(p=>p.key===key)?.baseCost || 100);
  let mult = 1.45;
  if (PRODUCTION_BUILDINGS.some(b=>b.key===key)) mult = 1.6;
  if (base >= 5000) mult = Math.max(mult,1.7);
  return Math.floor(base * Math.pow(mult, level));
}

function buyUpgrade(key){
  const up = state.upgrades[key];
  if (!up) return false;
  const c = costFor(key, up.level);
  if (state.data < c) return false;
  state.data -= c;
  up.level++;
  // If it's a production building and was 0->1, create building slot
  if (PRODUCTION_BUILDINGS.some(b=>b.key===key)){
    const exists = state.buildings.find(x=>x.key===key);
    if (!exists) {
      state.buildings.push({ key:key, xIndex: state.buildings.length, accumulator:0 });
      // small POP effect
      spawnSmokeAtBuilding(key,3);
    }
  }
  // upgrade flash
  upgradeFlashFor(key);
  save();
  return true;
}

/* visual flash on upgrade */
function upgradeFlashFor(key){
  // find building position element via local calculation and produce a screen flash / popup
  const bb = boundingForBuildingKey(key);
  if (!bb) return;
  const popup = document.createElement('div');
  popup.className = 'production-animation upgrade-flash';
  popup.style.left = (bb.cx) + 'px';
  popup.style.top = (bb.cy - 22) + 'px';
  popup.style.color = '#fff';
  popup.style.fontSize = '14px';
  popup.textContent = 'UPGRADE!';
  productionAnimContainer.appendChild(popup);
  setTimeout(()=>popup.remove(),700);
}

/* ------------------------------
   Building rendering & layout
   ------------------------------ */

/* compute active buildings (ordered) */
function activeBuildings(){
  // show only production buildings with level>0, keep PRODUCTION_BUILDINGS order
  return PRODUCTION_BUILDINGS.filter(p => state.upgrades[p.key] && state.upgrades[p.key].level > 0);
}

/* bounding box for building icons (in canvas coordinates) */
function boundingForBuildingIndex(index){
  const active = activeBuildings();
  if (active.length===0) return null;
  const padding = 30;
  const size = Math.min(72, Math.max(48, Math.floor(canvas.width * 0.08))); // responsive
  const spacing = 14;
  const totalWidth = active.length * (size + spacing) - spacing;
  const startX = canvas.width/2 - totalWidth/2 + size/2;
  const x = startX + index * (size + spacing);
  const y = canvas.height - padding - 25;
  return { x:x, y:y, w:size, h:size, cx:x, cy:y };
}

/* find bounding for building key */
function boundingForBuildingKey(key){
  const active = activeBuildings();
  const idx = active.findIndex(b => b.key === key);
  if (idx === -1) return null;
  return boundingForBuildingIndex(idx);
}

/* check click hit on building */
function buildingAtPoint(px,py){
  const active = activeBuildings();
  for (let i=0;i<active.length;i++){
    const b = boundingForBuildingIndex(i);
    if (!b) continue;
    const dx = px - b.cx, dy = py - b.cy;
    const radius = Math.max(b.w,b.h)/2;
    if (Math.sqrt(dx*dx+dy*dy) <= radius) {
      return active[i];
    }
  }
  return null;
}

/* draw buildings with glow/pulse and production text */
function drawBuildings(now){
  const act = activeBuildings();
  if (act.length===0) return;
  const padding = 30;
  const size = Math.min(72, Math.max(48, Math.floor(canvas.width * 0.08)));
  const spacing = 14;
  const totalWidth = act.length * (size + spacing) - spacing;
  const startX = canvas.width/2 - totalWidth/2 + size/2;
  const pulse = 1 + Math.sin(state.gameTime/220) * 0.04;
  act.forEach((proto,i) => {
    const up = state.upgrades[proto.key];
    const x = startX + i*(size+spacing);
    const y = canvas.height - padding - 25;
    // background glow
    ctx.save();
    ctx.translate(x,y);
    ctx.beginPath();
    ctx.fillStyle = proto.color;
    ctx.globalAlpha = 0.07;
    ctx.arc(0,0,Math.floor(size*0.8)*pulse,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    // emoji
    ctx.font = `${Math.floor(size*0.6)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#fff';
    ctx.fillText(proto.emoji, 0, -6);
    // small production text
    ctx.font = `12px 'Chakra Petch'`;
    ctx.fillStyle = proto.color;
    const perSec = Math.round(up.effect(up.level));
    ctx.fillText(`+${perSec} /s`, 0, 28);
    // level
    ctx.font = `10px 'Chakra Petch'`;
    ctx.fillStyle = '#cbd5e1';
    ctx.fillText(`Lv. ${up.level}`, 0, -28);
    ctx.restore();
  });
}

/* --- Smoke & Visual Particles for buildings --- */
function spawnSmokeAtBuilding(key, count=2){
  const b = boundingForBuildingKey(key);
  if (!b) return;
  for (let i=0;i<count;i++){
    smokeParticles.push({
      x: b.cx + (Math.random()-0.5)*10,
      y: b.cy + 6,
      vx: (Math.random()-0.5)*0.2,
      vy: -0.3 - Math.random()*0.3,
      life: 60 + Math.random()*40,
      size: 10 + Math.random()*10,
      alpha: 0.9
    });
  }
}

/* update smoke */
function updateSmoke(delta){
  for (let i=smokeParticles.length-1;i>=0;i--){
    const s = smokeParticles[i];
    s.x += s.vx * delta/16;
    s.y += s.vy * delta/16;
    s.life -= delta/16;
    s.alpha *= 0.995;
    if (s.life <= 0) smokeParticles.splice(i,1);
  }
}
function drawSmoke(){
  smokeParticles.forEach(s=>{
    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(0.9, s.alpha * (s.life/100)));
    ctx.fillStyle = `rgba(200,200,210, ${0.06 + 0.34*(s.alpha)})`;
    ctx.beginPath();
    ctx.ellipse(s.x, s.y, s.size*0.7, s.size*0.45, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
}

/* ------------------------------
   Production: continuous per-frame
   ------------------------------ */
function updateProduction(delta){
  state.gameTime += delta;
  // Per-building continuous production
  let producedThisFrame = 0;
  state.buildings.forEach(b => {
    const up = state.upgrades[b.key];
    if (!up || up.level<=0) return;
    const perSec = up.effect(up.level); // production per second
    const produced = perSec * (delta/1000);
    state.data += produced;
    producedThisFrame += produced;
    b.accumulator = (b.accumulator || 0) + produced;
    // When accumulator exceeds threshold (>=1) show popup for integer part
    if (b.accumulator >= 1){
      const amount = Math.floor(b.accumulator);
      b.accumulator -= amount;
      createProductionPopup(b.key, amount);
    }
    // occasional "critical" bonus (rare, scales with level)
    const critChance = 0.0006 * (1 + up.level/40);
    if (Math.random() < critChance){
      const bonus = Math.floor(perSec * 1.2 + Math.random()*perSec);
      state.data += bonus;
      createProductionPopup(b.key, bonus, true);
      playSine(950, 0.12, 0.6);
    }
    // emit small smoke occasionally for visual life
    if (Math.random() < 0.01) spawnSmokeAtBuilding(b.key, 1);
  });

  // Video progress (frame accurate)
  const baseProgress = 1.0 + state.videoLevel*0.08;
  const prodSpeedMultiplier = state.upgrades.prodSpeed.effect(state.upgrades.prodSpeed.level);
  const finalProgressRate = baseProgress * prodSpeedMultiplier;
  state.videoProgress = Math.min(100, state.videoProgress + finalProgressRate * delta/1000);
  if (state.videoProgress >= 100){
    publishVideo();
    state.videoProgress = 0;
  }

  // cooldowns
  state.cooldowns.shot = Math.max(0, state.cooldowns.shot - delta/1000);
  state.cooldowns.protectorShot -= delta;
}

/* production popup DOM */
function createProductionPopup(key, amount, isCrit=false){
  const bound = boundingForBuildingKey(key);
  if (!bound) return;
  const id = 'prod-' + Date.now() + Math.random().toString(36).slice(2,7);
  const el = document.createElement('div');
  el.id = id;
  el.className = 'production-animation';
  el.style.left = (bound.cx) + 'px';
  el.style.top = (bound.cy - 28) + 'px';
  el.style.color = isCrit ? '#ffe28a' : '#e6f0ff';
  el.style.fontSize = isCrit ? '16px' : '14px';
  el.textContent = (isCrit? 'CRIT ' : '') + '+' + Math.floor(amount) + ' üíø';
  productionAnimContainer.appendChild(el);
  setTimeout(()=>{ el.remove(); }, 900);
}

/* ------------------------------
   Bugs, projectiles, drops
   ------------------------------ */
const BUG_EMOJIS = ['üêõ','üêû','ü¶†'];

function spawnBug(){
  state.maxBugs = Math.max(5, Math.floor(5 + state.videoLevel*1.5));
  if (bugs.length >= state.maxBugs) return;
  const side = Math.floor(Math.random()*4);
  let x,y;
  const sizeRand = Math.random();
  let type='normal', size=16, damage=5, speed=1.2, maxHP=6;
  if (sizeRand<0.08){ type='large'; size=28; damage=10 + state.videoLevel; speed=0.6 + state.videoLevel*0.02; maxHP = Math.max(8, 12 + state.videoLevel*2); }
  else if (sizeRand<0.22){ type='small'; size=10; damage=2 + Math.floor(state.videoLevel*0.15); speed=2.4 + state.videoLevel*0.08; maxHP = Math.max(2, 3 + Math.floor(state.videoLevel*0.5)); }
  else { type='normal'; size=16; damage=4 + Math.floor(state.videoLevel*0.5); speed=1.2 + state.videoLevel*0.05; maxHP = Math.max(4, 6 + Math.floor(state.videoLevel*1.0)); }

  if (side===0){ x=Math.random()*canvas.width; y=-size*2; }
  else if (side===1){ x=canvas.width + size*2; y=Math.random()*canvas.height; }
  else if (side===2){ x=Math.random()*canvas.width; y=canvas.height + size*2; }
  else { x=-size*2; y=Math.random()*canvas.height; }
  bugs.push({ x,y,size,type,damage,speed,angle:0, maxHP, hp:maxHP, emoji:BUG_EMOJIS[Math.floor(Math.random()*BUG_EMOJIS.length)] });
}

function updateBugs(delta){
  // bugs move toward player (they never target buildings), if they reach player they damage HP then die
  for (let i=bugs.length-1;i>=0;i--){
    const b = bugs[i];
    const dx = PLAYER.x - b.x;
    const dy = PLAYER.y - b.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const ang = Math.atan2(dy,dx);
    b.x += Math.cos(ang) * b.speed * (delta/16);
    b.y += Math.sin(ang) * b.speed * (delta/16);
    b.angle = ang;
    // collision with player
    const radius = Math.min(canvas.width, canvas.height) * PLAYER_SIZE_PERCENTAGE * 0.5;
    if (dist < radius + b.size/2){
      takeDamage(b.damage);
      // drop some data on death
      const dataDrop = Math.floor((b.type==='large'?80:(b.type==='small'?6:20)) * (1 + (state.upgrades.moreData.level || 0)));
      state.data += dataDrop;
      createDataDrop(b.x,b.y,dataDrop, Math.random() < state.upgrades.goldenDropChance.effect(state.upgrades.goldenDropChance.level));
      bugs.splice(i,1);
      playSine(240,0.08,0.6);
    } else {
      // occasionally bugs take damage from projectiles handled elsewhere
    }
    if (b.hp <= 0){
      // death
      const dataDrop = Math.floor((b.type==='large'?80:(b.type==='small'?6:20)) * (1 + (state.upgrades.moreData.level || 0)));
      state.data += dataDrop;
      createDataDrop(b.x,b.y,dataDrop, Math.random() < state.upgrades.goldenDropChance.effect(state.upgrades.goldenDropChance.level));
      bugs.splice(i,1);
      playSine(330,0.06,0.6);
    }
  }
}

function takeDamage(dmg){
  state.playerHP -= dmg;
  // camera shake mimic: small canvas translation for brief frame
  // we just play sound + minor visual effect
  playSine(120,0.12,0.8);
  if (state.playerHP <= 0 && !isGameOver){
    isGameOver = true;
    showGameOver();
  }
}

/* projectiles */
function fireProjectile(tx,ty){
  const dam = state.upgrades.attackDamage.effect(state.upgrades.attackDamage.level);
  const angle = Math.atan2(ty-PLAYER.y, tx-PLAYER.x);
  projectiles.push({ x:PLAYER.x, y:PLAYER.y, angle, speed:16, damage:dam, life:120 });
  playSine(900,0.04,0.5);
}

function updateProjectiles(delta){
  for (let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.x += Math.cos(p.angle) * p.speed * (delta/16);
    p.y += Math.sin(p.angle) * p.speed * (delta/16);
    p.life -= delta/16;
    if (p.life<=0 || p.x<0 || p.x>canvas.width || p.y<0 || p.y>canvas.height){
      projectiles.splice(i,1); continue;
    }
    // collision with bugs
    for (let j=bugs.length-1;j>=0;j--){
      const b = bugs[j];
      const dx = p.x - b.x, dy = p.y - b.y;
      if (Math.sqrt(dx*dx+dy*dy) < b.size){
        b.hp -= p.damage;
        // particle
        if (Math.random()<0.4) particles.push({ x:p.x, y:p.y, vx:(Math.random()-0.5)*2, vy:(Math.random()-1)*2, life:30, emoji:'‚ú®', value:0 });
        projectiles.splice(i,1);
        break;
      }
    }
  }
}

/* drops (particles) */
function createDataDrop(x,y,value,isGold=false){
  const split = isGold ? 5 : 1;
  for (let i=0;i<split;i++){
    particles.push({ x:x, y:y, vx:(Math.random()-0.5)*3, vy:(Math.random()-2.5)*3, life:50, emoji: isGold ? 'üìÄ' : 'üíø', value: Math.floor(value/split)});
  }
}
function updateParticles(delta){
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.vy += 0.12 * (delta/16);
    p.x += p.vx * (delta/16);
    p.y += p.vy * (delta/16);
    p.life -= delta/16;
    // pickup if near player
    const dx = p.x - PLAYER.x, dy = p.y - PLAYER.y;
    if (Math.sqrt(dx*dx+dy*dy) < Math.min(canvas.width,canvas.height)*PLAYER_SIZE_PERCENTAGE*0.45){
      state.data += p.value;
      particles.splice(i,1);
      playSine(1200,0.04,0.5);
      continue;
    }
    if (p.life<=0) particles.splice(i,1);
  }
}

/* protector automatic shooting (floppyProtector) */
function updateProtectors(delta){
  const level = state.upgrades.floppyProtector.level;
  if (level<=0) return;
  state.cooldowns.protectorShot -= delta;
  if (state.cooldowns.protectorShot <= 0){
    if (bugs.length>0){
      // target nearest bug
      let closest = null; let distMin = Infinity;
      for (const b of bugs){
        const dx = b.x - PLAYER.x, dy = b.y - PLAYER.y;
        const d = Math.sqrt(dx*dx+dy*dy);
        if (d < distMin){ distMin = d; closest = b; }
      }
      if (closest){
        // fire "level" projectiles with slight spread
        const shots = Math.min(level, 12); // cap for perf
        for (let i=0;i<shots;i++){
          const angle = Math.atan2(closest.y-PLAYER.y, closest.x-PLAYER.x) + (Math.random()-0.5)*0.14;
          projectiles.push({ x:PLAYER.x, y:PLAYER.y, angle, speed:14, damage: Math.max(1, Math.round(state.upgrades.attackDamage.effect(state.upgrades.attackDamage.level)/2)), life:100 });
        }
        playSine(1500,0.06,0.35);
      }
    }
    state.cooldowns.protectorShot = 5000; // 5s
  }
}

/* spawn logic */
function updateSpawning(delta){
  const minInterval = 450;
  const base = 3000;
  const reduce = state.videoLevel * 55;
  const interval = Math.max(minInterval, base - reduce);
  if (state.gameTime - state.lastBugSpawn > interval){
    const toSpawn = Math.min(Math.floor(Math.random()*3)+1, Math.max(1, state.maxBugs - bugs.length));
    for (let i=0;i<toSpawn;i++) spawnBug();
    state.lastBugSpawn = state.gameTime;
  }
}

/* publish video */
const PARKS = ["Europa-Park","Phantasialand","Heide Park","Movie Park","Hansa-Park","Legoland"];
const TITLES = ["Unfassbar 2026!","Die Top Attraktionen","Vlog ‚Äì 12 Stunden","Winter-Special 2025","Neues Review","Warum das erstaunlich ist"];
function publishVideo(){
  state.videoLevel++;
  const baseViews = Math.floor(18 * (1 + state.videoLevel*0.12) * (1 + state.videoLevel*0.6));
  const vb = Math.floor(baseViews * state.upgrades.viewBoost.effect(state.upgrades.viewBoost.level));
  state.views += vb;
  state.maxBugs = Math.floor(5 + state.videoLevel*1.5);
  const park = PARKS[Math.floor(Math.random()*PARKS.length)];
  state.lastTitle = TITLES[Math.floor(Math.random()*TITLES.length)] + ' ‚Äî ' + park;
  videoTitleEl.textContent = state.lastTitle;
  playSine(1200,0.18,0.6);
}

/* ------------------------------
   UI update + draw
   ------------------------------ */
function updateUI(){
  dataCountEl.textContent = Math.floor(state.data).toLocaleString();
  viewsCountEl.textContent = Math.floor(state.views).toLocaleString();
  currentBugsEl.textContent = bugs.length;
  maxBugsEl.textContent = state.maxBugs;
  videoBarEl.style.width = state.videoProgress + '%';
  // production rate: sum of production building effects
  let total = 0;
  PRODUCTION_BUILDINGS.forEach(p => {
    const up = state.upgrades[p.key];
    if (up && up.level>0) total += up.effect(up.level);
  });
  prodRateEl.textContent = Math.round(total).toLocaleString();
}

/* draw everything */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background grid subtle
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#fff';
  for (let x=0;x<canvas.width;x+=40){
    ctx.fillRect(x,0,1,canvas.height);
  }
  for (let y=0;y<canvas.height;y+=40){
    ctx.fillRect(0,y,canvas.width,1);
  }
  ctx.restore();

  // particles (drops)
  particles.forEach(p=>{
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.font = '18px serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.emoji,0,0);
    ctx.restore();
  });

  // bugs
  bugs.forEach(b=>{
    ctx.save();
    ctx.translate(b.x,b.y);
    ctx.font = `${b.size*2}px serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(b.emoji,0,0);
    // hp bar
    if (b.hp < b.maxHP){
      const w = b.size*2.2, h=4;
      const yoff = -b.size - 8;
      ctx.fillStyle='#222'; ctx.fillRect(-w/2,yoff,w,h);
      const ratio = Math.max(0, b.hp / b.maxHP);
      ctx.fillStyle = ratio>0.5? '#34D399' : (ratio>0.2? '#FBBF24' : '#EF4444');
      ctx.fillRect(-w/2,yoff,w*ratio,h);
    }
    ctx.restore();
  });

  // projectiles
  projectiles.forEach(p=>{
    ctx.save();
    ctx.fillStyle = '#fef08a';
    ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // smoke under buildings
  drawSmoke();

  // draw buildings last (so they look foreground)
  drawBuildings();

  // draw player circle (we actually have a DOM element for player emoji + svg ring)
  // draw protectors around player (visual)
  const protLevel = state.upgrades.floppyProtector.level;
  if (protLevel>0){
    const orbitR = Math.min(canvas.width,canvas.height)*0.12;
    for (let i=0;i<Math.min(protLevel,8);i++){
      const ang = (state.gameTime/9000)*(i+1) + (i/8)*Math.PI*2;
      ctx.save(); ctx.translate(PLAYER.x + Math.cos(ang)*orbitR, PLAYER.y + Math.sin(ang)*orbitR);
      ctx.font = '18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üíæ',0,0); ctx.restore();
    }
  }

  // production popups handled in DOM for crisp font (we added them earlier)
}

/* ------------------------------
   Building popup UI (Variant A)
   ------------------------------ */
const popupEmoji = document.getElementById('popupEmoji');
const popupName = document.getElementById('popupName');
const popupDesc = document.getElementById('popupDesc');
const popupLevel = document.getElementById('popupLevel');
const popupProd = document.getElementById('popupProd');
const popupCost = document.getElementById('popupCost');
const popupMore = document.getElementById('popupMore');
const popupUpgradeBtn = document.getElementById('popupUpgradeBtn');
const popupCloseBtn = document.getElementById('popupCloseBtn');

let popupOpenFor = null;

function openBuildingPopup(key, cx, cy){
  const proto = PRODUCTION_BUILDINGS.find(p=>p.key===key);
  const up = state.upgrades[key];
  if(!proto || !up) return;
  popupEmoji.textContent = proto.emoji;
  popupName.textContent = proto.name;
  popupDesc.textContent = up.desc;
  popupLevel.textContent = 'Lv. ' + up.level;
  popupProd.textContent = '+' + Math.round(up.effect(up.level)).toLocaleString();
  const cst = costFor(key, up.level);
  popupCost.textContent = cst.toLocaleString();
  popupMore.textContent = 'Klicke Upgrade um nur dieses Geb√§ude zu verbessern.';
  popupUpgradeBtn.disabled = (state.data < cst) || (up.level >= up.maxLevel);
  popupUpgradeBtn.style.opacity = (popupUpgradeBtn.disabled?0.5:1);
  // position popup above building
  buildingPopup.style.left = cx + 'px';
  buildingPopup.style.top = (cy - 40) + 'px';
  buildingPopup.classList.remove('hidden');
  popupOpenFor = key;
  // show subtle pointer by moving popup slightly if near edge
  window.requestAnimationFrame(()=>{ buildingPopup.classList.add('glow'); });
}

function closeBuildingPopup(){
  buildingPopup.classList.add('hidden');
  popupOpenFor = null;
}

popupCloseBtn.addEventListener('click', closeBuildingPopup);
popupUpgradeBtn.addEventListener('click', ()=> {
  if (!popupOpenFor) return;
  const key = popupOpenFor;
  const success = buyUpgrade(key);
  if (success){
    // refresh popup data quickly
    const up = state.upgrades[key];
    popupLevel.textContent = 'Lv. ' + up.level;
    popupProd.textContent = '+' + Math.round(up.effect(up.level));
    popupCost.textContent = costFor(key, up.level).toLocaleString();
    spawnSmokeAtBuilding(key, 4);
    playSine(700,0.08,0.5);
  } else {
    // cannot afford
    playSine(200,0.12,0.6);
    alert('Nicht genug Daten (üíø) f√ºr dieses Upgrade.');
  }
  updateUI();
});

/* clicking behavior: if click on building, open popup; otherwise fire shotgun toward click */
canvas.addEventListener('mousedown', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  // check building hit
  const hit = buildingAtPoint(cx,cy);
  if (hit){
    // open popup for that building
    const bb = boundingForBuildingKey(hit.key);
    if (bb) openBuildingPopup(hit.key, bb.cx, bb.cy - 10);
    return;
  }
  // closed popup if clicking elsewhere
  closeBuildingPopup();
  // else: shoot (manual)
  if (state.cooldowns.shot <= 0){
    // multishot count:
    const ms = state.upgrades.multiShot.effect(state.upgrades.multiShot.level);
    const spread = (ms>1) ? Math.PI/24 : 0;
    for (let i=0;i<ms;i++){
      const angleOff = (i - (ms-1)/2) * spread;
      const angle = Math.atan2(cy - PLAYER.y, cx - PLAYER.x) + angleOff;
      const tx = PLAYER.x + Math.cos(angle) * 1000;
      const ty = PLAYER.y + Math.sin(angle) * 1000;
      fireProjectile(tx,ty);
    }
    state.cooldowns.shot = state.upgrades.attackSpeed.effect(state.upgrades.attackSpeed.level);
  }
});

/* close popup if clicking outside DOM */
document.addEventListener('mousedown', (ev)=>{
  if (!buildingPopup.classList.contains('hidden')){
    const rect = buildingPopup.getBoundingClientRect();
    if (!(ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom)){
      // clicked outside popup -> close
      closeBuildingPopup();
    }
  }
});

/* ------------------------------
   Upgrade shop panel (full list) - optional trigger
   ------------------------------ */
function openShop(){
  const overlay = document.getElementById('modalOverlay');
  overlay.classList.remove('hidden');
  const list = document.getElementById('upgradeList');
  list.innerHTML = '';
  // show every upgrade (production first)
  const keys = Object.keys(state.upgrades);
  keys.forEach(k=>{
    const up = state.upgrades[k];
    const title = PRODUCTION_BUILDINGS.find(p=>p.key===k)?.name || k.replace(/([A-Z])/g,' $1');
    const cost = costFor(k, up.level);
    const card = document.createElement('div');
    card.className = 'liquid-glass p-3 flex items-center justify-between gap-3';
    card.innerHTML = `<div>
        <div class="font-bold">${title} <span class="small-muted text-xs">Lv.${up.level}</span></div>
        <div class="small-muted text-xs">${up.desc}</div>
      </div>
      <div class="flex flex-col items-end gap-2">
        <div class="font-bold">${cost.toLocaleString()} üíø</div>
        <div class="flex gap-2">
          <button class="btn buyUp" data-key="${k}">Kaufen</button>
        </div>
      </div>`;
    list.appendChild(card);
  });
  // bind buys
  document.querySelectorAll('.buyUp').forEach(btn=>{
    btn.onclick = ()=>{
      const k = btn.dataset.key;
      const ok = buyUpgrade(k);
      if (!ok) alert('Nicht genug Daten (üíø)');
      openShop(); // refresh
      updateUI();
    };
  });
}
document.getElementById('closeModal').addEventListener('click', ()=>document.getElementById('modalOverlay').classList.add('hidden'));

/* ------------------------------
   Main update loop
   ------------------------------ */
function gameTick(ts){
  const delta = Math.min(60, ts - lastTimestamp);
  lastTimestamp = ts;
  if (!isPaused && !isGameOver){
    // production
    updateProduction(delta);
    // spawn bugs
    updateSpawning(delta);
    // update bugs / projectiles / particles
    updateBugs(delta);
    updateProjectiles(delta);
    updateParticles(delta);
    updateSmoke(delta);
    updateProtectors(delta);
  }
  render();
  updateUI();
  save();
  requestAnimationFrame(gameTick);
}
requestAnimationFrame(gameTick);

/* --- initial small spawn for visual interest --- */
for (let i=0;i<3;i++) spawnBug();

/* ------------------------------
   Helper: show game over (simple)
   ------------------------------ */
function showGameOver(){
  alert('GAME OVER ‚Äî Du kannst neu starten, indem du die Seite neu l√§dst oder localStorage l√∂schst.');
  // freeze interactions
  isPaused = true;
}

/* ------------------------------
   Tiny keyboard helpers for debugging (optional)
   ------------------------------ */
window.addEventListener('keydown',(e)=>{
  if (e.key==='s') save();
  if (e.key==='l') load();
  if (e.key==='b') spawnBug();
});

/* End of file */
</script>

</body>
</html>

