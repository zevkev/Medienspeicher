<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Defender - Retro Tower Defense</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler.js/2.2.4/howler.min.js"></script>
<style>
  /* Custom Global Styles f√ºr Liquid Glass Effekt und Futura-√§hnliche Schrift */
  @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600&display=swap');
  :root {
    --player-actual-size: 80px; 
    --ring-width: 8px; 
    --player-visual-scale: 0.8; 
  }
  .futura { font-family: 'Chakra Petch', sans-serif; }
  .liquid-glass {
    backdrop-filter: blur(10px) saturate(180%);
    -webkit-backdrop-filter: blur(10px) saturate(180%);
    background-color: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(209, 213, 219, 0.3);
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
    background-image: linear-gradient(135deg, rgba(76, 29, 149, 0.7), rgba(49, 46, 129, 0.7)); 
  }
  
  @keyframes burst-shake {
    0% { transform: translate(0.5px, 0.5px) rotate(0deg); }
    10% { transform: translate(-0.5px, -1.5px) rotate(-0.25deg); }
    100% { transform: translate(0.5px, -1.5px) rotate(-0.25deg); }
  }
  .camera-shake { animation: burst-shake 0.15s ease-in-out; }

  /* Canvas Styling - Game-Elemente laufen HINTER dem SVG-Ring */
  #gameCanvas {
    touch-action: none; 
    border-radius: 12px;
    z-index: 10; 
  }
  
  /* Player Glow Animation */
  @keyframes pulse-glow {
    0%, 100% { 
        text-shadow: 0 0 5px #ffffff, 0 0 10px #0000ff; 
        transform: translate(-50%, -50%) scale(1);
    }
    50% { 
        text-shadow: 0 0 8px #ffffff, 0 0 15px #0000ff, 0 0 3px #0000ff;
        transform: translate(-50%, -50%) scale(1.01);
    }
  }

  #player {
    animation: pulse-glow 3s infinite ease-in-out; 
    font-size: var(--player-actual-size); 
    line-height: 1; 
    user-select: none;
    z-index: 30; 
  }

  /* Player Health Circle */
  #playerHealthCircle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20; 
    transition: all 0.2s ease-out;
  }
  .ring-gradient {
    transition: stroke-dashoffset 0.2s, stroke 0.2s;
    /* FIX: Runde Enden f√ºr den Ring */
    stroke-linecap: round; 
  }
  
  @keyframes pop-up {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-40px); opacity: 0; }
  }
  .production-animation {
      position: absolute;
      font-size: 1.4rem; 
      font-weight: bold;
      pointer-events: none;
      white-space: nowrap;
      animation: pop-up 1s ease-out forwards;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
  }
</style>

</head>
<body>
<!-- Haupt Container -->
<div id="app" class="futura flex flex-col items-center justify-center min-h-screen p-2 md:p-4 bg-gray-900 text-white select-none relative overflow-hidden">
  
  <!-- UI Bar oben -->
  <div id="uiBar" class="w-full max-w-5xl liquid-glass mb-2 p-2 flex justify-between items-center text-sm md:text-base order-1">
    
    <div id="videoInfo" class="flex-1 text-left mr-2">
      <div class="font-bold text-green-300">Views: <span id="viewsCount">0</span></div>
      <div id="videoTitle" class="text-xs italic truncate w-40 md:w-72">Erstes Video ver√∂ffentlicht</div>
    </div>
    
    <div class="flex-1 flex flex-col items-center mx-2">
      <div class="text-xs mb-1 font-bold text-yellow-300">Daten: <span id="dataCount">0</span> üíø</div>
      <div class="w-full h-2 bg-gray-700 rounded-full">
        <div id="videoBar" class="h-2 rounded-full transition-all duration-300 bg-gradient-to-r from-purple-400 to-pink-500" style="width: 0%;"></div>
      </div>
      <div class="text-xs mt-1 text-gray-300">Produktion</div>
    </div>

    <div class="flex-1 flex justify-end items-center space-x-2">
      <div class="text-right mr-2">
        <div class="text-xs text-red-300">Bugs: <span id="currentBugs">0</span>/<span id="maxBugs">5</span></div>
        <div class="text-xs text-blue-300">Prod: +<span id="prodRate">0</span> üíø/s</div>
      </div>
      
      <button id="shopBtn" class="liquid-glass p-2 text-xl hover:scale-105 transition-transform">üõçÔ∏è</button>
      <button id="settingsBtn" class="liquid-glass p-2 text-xl hover:scale-105 transition-transform">‚öôÔ∏è</button>
    </div>
  </div>

  <!-- Haupt Game Canvas und Player -->
  <div id="gameContainer" class="relative w-full max-w-5xl aspect-video bg-gray-800 rounded-xl shadow-2xl overflow-hidden order-3">
    <!-- Game Canvas -->
    <canvas id="gameCanvas" class="w-full h-full"></canvas>
    
    <!-- Station√§rer Player in der Mitte -->
    <div id="player" class="absolute z-30" style="top: 50%; left: 50%; transform: translate(-50%, -50%);">
      üíæ
    </div>

    <!-- Kreisrunde Lebensanzeige (SVG) um den Player -->
    <svg id="playerHealthCircle" 
         viewBox="0 0 110 110" 
         style="width: 100px; height: 100px;"> 
      <circle id="hpRing" 
              class="ring-gradient" 
              cx="55" cy="55" 
              r="50" 
              stroke="#34D399" 
              stroke-width="var(--ring-width)" 
              fill="none" 
              transform="rotate(-90 55 55)"></circle>
    </svg>
    
    <!-- Container f√ºr Produktionsanimationen -->
    <div id="productionAnimContainer" class="absolute inset-0 pointer-events-none z-40"></div>
  </div>

  <!-- Modale Fenster (Shop / Settings / Info / Game Over) -->
  <div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">

    <!-- Shop Modal -->
    <div id="shopModal" class="liquid-glass w-full max-w-xl p-4 md:p-6 hidden">
      <h2 class="text-2xl md:text-3xl mb-4 text-center font-bold text-yellow-400">Daten Upgrade</h2>
      <div id="upgradeList" class="space-y-3 overflow-y-auto max-h-96 pr-2">
        <!-- Upgrades werden hier von JS eingef√ºgt (sortiert) -->
      </div>
      <button id="closeShopBtn" class="w-full mt-6 p-3 bg-red-600 hover:bg-red-700 rounded-lg transition-colors font-bold">Schlie√üen</button>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="liquid-glass w-full max-w-sm p-6 hidden">
      <h2 class="text-2xl md:text-3xl mb-4 text-center font-bold text-blue-400">Einstellungen</h2>
      <label for="volumeSlider" class="block mb-2 text-lg">Lautst√§rke</label>
      <input type="range" id="volumeSlider" min="0" max="100" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
      <button id="closeSettingsBtn" class="w-full mt-6 p-3 bg-red-600 hover:bg-red-700 rounded-lg transition-colors font-bold">Schlie√üen</button>
    </div>
    
    <!-- Info Popup -->
    <div id="infoPopup" class="liquid-glass w-full max-w-sm p-6 hidden">
      <h3 id="infoTitle" class="text-xl font-bold mb-2 text-center text-indigo-300"></h3>
      <p id="infoText" class="text-sm text-gray-200 mb-4"></p>
      <button id="closeInfoBtn" class="w-full p-3 bg-red-600 hover:bg-red-700 rounded-lg transition-colors font-bold">OK</button>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="liquid-glass w-full max-w-md p-6 hidden text-center">
      <h2 class="text-4xl font-extrabold text-red-500 mb-4">GAME OVER</h2>
      <p class="text-xl mb-6">Dein Score: <span id="finalScore" class="font-bold text-yellow-300">0</span> Views</p>
      <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20" class="w-full p-3 mb-4 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500">
      <button id="submitScoreBtn" class="w-full p-3 bg-green-600 hover:bg-green-700 rounded-lg transition-colors font-bold">Score an Discord senden & Neustart</button>
    </div>

  </div>
</div>

<script>
  // --- KONSTANTEN UND INITIALISIERUNG ---
  const CANVAS = document.getElementById('gameCanvas');
  const CTX = CANVAS.getContext('2d');
  const PRODUCTION_ANIM_CONTAINER = document.getElementById('productionAnimContainer');
  let PLAYER_POS = { x: 0, y: 0 }; 
  const PLAYER_SIZE_PERCENTAGE = 0.15; 
  const RING_SPACING_FACTOR = 0.2; 
  const RING_MAX_OFFSET_FACTOR = 1.0; 
  const SVG_RING_R = 50; 
  const SVG_RING_CX = 55;
  
  // Bug Emojis auf 3 reduziert
  const BUG_EMOJIS = ['üêõ', 'üêû', 'ü¶†']; 

  const PARK_NAMES = [ "Europa-Park", "Phantasialand", "Heide Park Resort", "Movie Park Germany", "Hansa-Park", "Legoland Deutschland Resort" ];
  const VIDEO_TITLES = [ "2026 ‚Äì das wird krank!", "Alle Neuheiten 2026", "Top 10 Bahnen in", "mit Kindern ‚Äì 100% Empfehlung", "Warum gerade alle schl√§gt", "Vlog ‚Äì 12 Stunden Vollgas", "Horror in ‚Äì ich war fertig", "Wintertraum 2025/26" ];

  const DISCORD_WEBHOOK = "https://discord.com/api/webhooks/1445472531413991580/DcsBOrTXpI8vjZFaWAM8jZFaWAM8jO9uitsn7ZzhrzsAskeWcaMypXM8U7Gjxgloe0gdhac7jV-9";

  let lastTime = 0;
  let bugs = [];
  let projectiles = [];
  let particles = []; 
  let productionAnimations = []; 
  let isGamePaused = false;
  let frameCount = 0;
  let isGameOver = false;

  const PRODUCTION_BUILDINGS = [
    { key: 'dataFactory', emoji: 'üè≠', color: '#facc15' }, 
    { key: 'serverFarm', emoji: 'üíΩ', color: '#60a5fa' }, 
    { key: 'quantumCache', emoji: 'üíé', color: '#a78bfa' }, 
    { key: 'neuralNetCluster', emoji: 'üß†', color: '#818cf8' }, 
    { key: 'globalCDN', emoji: 'üåê', color: '#34d399' }, 
  ];

  const INITIAL_GAME_STATE = {
    views: 0, data: 0, playerHP: 100, maxPlayerHP: 100, videoProgress: 0, videoLevel: 0,
    maxBugs: 5, lastVideoTitle: "Willkommen!", gameTime: 0, lastProductionTime: 0,
    lastBugSpawnTime: 0, bugSpawnInterval: 3000, 
    upgrades: {
      // Produktionsgeb√§ude
      dataFactory: { level: 0, baseCost: 1000, desc: "Eine üè≠ die Daten pro Sekunde generiert.", effect: (l) => 10 + l * 5, maxLevel: 100 },
      serverFarm: { level: 0, baseCost: 5000, desc: "Eine üíΩ die grosse Datenpakete pro Sekunde generiert.", effect: (l) => 100 + l * 50, maxLevel: 100 },
      quantumCache: { level: 0, baseCost: 15000, desc: "Ein üíé Quanten-Cache erh√∂ht die Produktionsrate stark.", desc_short: "Quanten-Cache", effect: (l) => 500 + l * 250, maxLevel: 100 },
      neuralNetCluster: { level: 0, baseCost: 75000, desc: "Ein üß† Neuronales Netz generiert extrem schnell Daten.", desc_short: "Neuronales Netz", effect: (l) => 3000 + l * 1500, maxLevel: 100 },
      globalCDN: { level: 0, baseCost: 300000, desc: "Ein üåê Globales CDN generiert massive Datenmengen.", desc_short: "Globales CDN", effect: (l) => 15000 + l * 7500, maxLevel: 100 },
      
      // Upgrade Geschwindigkeit/Effizienz
      prodSpeed: { level: 0, baseCost: 100, desc: "Produktions-Turbo: Beschleunigt die Rate, mit der neue Videos fertiggestellt werden. Max. 4 Sekunden pro Video bei Level 100.", effect: (l) => 1 + l * 0.24, maxLevel: 100 },
      
      // FIX: moreData: skaliert jetzt von x1 (Lv 0) zu x2 (Lv 1) zu x(L+1) bei Lv L
      moreData: { level: 0, baseCost: 50, desc: "Erh√∂ht die Basis-Daten (üíø) die Bugs droppen. Bei Level L wird ein Multiplikator von (L+1) angewendet. Max. x101 bei Level 100.", effect: (l) => 1 + l, maxLevel: 100 }, 
      
      // NEU: attackDamage: Erh√∂ht den Schaden des Projektils
      attackDamage: { level: 0, baseCost: 100, desc: "Erh√∂ht den Schaden der Projektile um 1 pro Level. Startet bei 1 Schaden.", effect: (l) => 1 + l, maxLevel: 100 },
      
      // NEU: Golden Drop Chance Upgrade (Max Level 100, 10% -> 100%)
      goldenDropChance: { level: 0, baseCost: 500, desc: "Erh√∂ht die Chance, dass Bugs üìÄ (Gold CDs mit 10x Daten) droppen. Startet bei 10%. Max. 100% bei Level 100.", desc_short: "Gold Drop Chance", effect: (l) => 0.1 + l * 0.009, maxLevel: 100 },
      
      viewBoost: { level: 0, baseCost: 200, desc: "Erh√∂ht die Views pro Video exponentiell.", effect: (l) => 1 + l * 0.2, maxLevel: 100 },
      attackSpeed: { level: 0, baseCost: 100, desc: "Reduziert die Abklingzeit des manuellen Schusses. Minimal 0.05s bei Level 100.", effect: (l) => Math.max(0.05, 0.5 - l * 0.0045), maxLevel: 100 }, 
      
      multiShot: { level: 0, baseCost: 400, desc: "Dein üíæ schie√üt mehr als ein Projektil.", effect: (l) => 1 + l, maxLevel: 100 },
      hpRegen: { level: 0, baseCost: 250, desc: "Regeneriert einen kleinen Teil der HP pro Sekunde.", effect: (l) => 0.1 + l * 0.05, maxLevel: 100 },
      
      // ANPASSUNG: Floppy Protector mit neuem, hohen exponentiellen Preis-Multiplikator
      // Basispreis 150, Multiplikator 2.5x, maxLevel hoch gesetzt, um die Struktur zu wahren
      floppyProtector: { 
          level: 0, 
          baseCost: 150, 
          desc: "Ein üíæ-Drohne, die den Player umkreist und alle 5s automatisch schie√üt. Steigt exponentiell im Preis (2.5x pro Level).", 
          desc_short: "Floppy Protector", 
          effect: (l) => l, 
          maxLevel: 1000 // Sehr hohes Level, um ein faktisches 'unendlich' zu erreichen
      },
    },
    settings: { volume: 50 },
    // Cooldowns f√ºr manuellen Schuss und Protector
    cooldowns: { shot: 0, protectorShot: 5000 } 
  };

  let gameState = JSON.parse(JSON.stringify(INITIAL_GAME_STATE)); 
  
  // --- AUDIO SYSTEM ---
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  let masterGain = audioContext.createGain();
  masterGain.connect(audioContext.destination);

  function playSound(freq, duration, type, volume = 1) {
    if (audioContext.state === 'suspended') { audioContext.resume(); }
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    gainNode.gain.setValueAtTime(volume * (gameState.settings.volume / 100), audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
    oscillator.connect(gainNode);
    gainNode.connect(masterGain);

    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
  }

  // --- PERSISTENCE ---

  function loadGameState() {
    const savedState = localStorage.getItem('codeDefenderState');
    
    // Wir laden die Basisstruktur immer neu, um neue Upgrades hinzuzuf√ºgen/entfernen
    const baseState = JSON.parse(JSON.stringify(INITIAL_GAME_STATE));
    
    if (savedState) {
      const loaded = JSON.parse(savedState);
      
      // Allgemeine Zust√§nde √ºbernehmen
      Object.keys(loaded).forEach(key => {
          if (key !== 'upgrades' && key !== 'settings' && baseState.hasOwnProperty(key)) {
              baseState[key] = loaded[key];
          }
      });
      
      // Upgrades √ºbernehmen (nur Level, um neue Upgrades zu initialisieren)
      Object.keys(baseState.upgrades).forEach(key => {
        if (loaded.upgrades && loaded.upgrades[key] && loaded.upgrades[key].level !== undefined) {
          // Stellen Sie sicher, dass nur Upgrades √ºbernommen werden, die noch existieren
          if (baseState.upgrades.hasOwnProperty(key)) {
             baseState.upgrades[key].level = loaded.upgrades[key].level;
          }
        }
      });
      
      // Einstellungen
      if (loaded.settings) { Object.assign(baseState.settings, loaded.settings); }
      // Cooldowns vom geladenen State entfernen/korrigieren
      if (loaded.cooldowns) { 
          if (loaded.cooldowns.shot !== undefined) baseState.cooldowns.shot = loaded.cooldowns.shot; 
          if (loaded.cooldowns.protectorShot !== undefined) baseState.cooldowns.protectorShot = loaded.cooldowns.protectorShot; 
      }

      gameState = baseState; // √úbernehme den gefilterten State
      
      // Initialisierung f√ºr Game Loop
      gameState.lastProductionTime = gameState.gameTime || 0; 
      gameState.lastBugSpawnTime = gameState.gameTime || 0;
    } else {
        gameState = baseState;
    }
    
    // Max Bugs basierend auf videoLevel neu berechnen
    gameState.maxBugs = Math.floor(5 + gameState.videoLevel);

    updateUI();
    masterGain.gain.setValueAtTime(gameState.settings.volume / 100, audioContext.currentTime);
    document.getElementById('volumeSlider').value = gameState.settings.volume;
  }

  function saveGameState() { localStorage.setItem('codeDefenderState', JSON.stringify(gameState)); }
  
  function resetGameState() {
      localStorage.removeItem('codeDefenderState');
      gameState = JSON.parse(JSON.stringify(INITIAL_GAME_STATE));
      isGameOver = false; bugs = []; projectiles = []; particles = []; 
      gameState.lastProductionTime = 0; gameState.lastBugSpawnTime = 0;
      // Max Bugs neu setzen
      gameState.maxBugs = 5; 
      document.getElementById('gameOverModal').classList.add('hidden');
      document.getElementById('modalOverlay').classList.add('hidden');
      isGamePaused = false;
      resizeCanvas(); 
      updateUI();
      if (!window.gameLoopRunning) { window.gameLoopRunning = true; requestAnimationFrame(gameLoop); }
  }

  // --- UI UPDATE & RENDERING ---

  function calculateProductionRate() {
      let totalIncome = 0;
      PRODUCTION_BUILDINGS.forEach(building => {
          const up = gameState.upgrades[building.key];
          // √úberpr√ºfen, ob das Upgrade existiert und eine 'effect'-Funktion hat
          if (up && up.level > 0 && typeof up.effect === 'function') { 
              totalIncome += up.effect(up.level); 
          }
      });
      return totalIncome;
  }

  function getPlayerCollisionRadius(ringReferenceSize) {
    return ringReferenceSize * 0.4;
  }

  function updateHealthRing(playerSizePixels) {
    const healthPercent = gameState.playerHP / gameState.maxPlayerHP;
    const ring = document.getElementById('hpRing');
    const svg = document.getElementById('playerHealthCircle');
    
    const playerRadiusPixels = playerSizePixels / 2;
    const minRadius = playerRadiusPixels * (1 + RING_SPACING_FACTOR);
    const maxRadius = minRadius + (playerRadiusPixels * RING_MAX_OFFSET_FACTOR); 
    const inverseRatio = 1 - healthPercent; 
    const currentRadius = minRadius + (maxRadius - minRadius) * inverseRatio;
    
    // FIX: Berechnung basierend auf den neuen SVG-Werten
    const svgDiameter = currentRadius * 2;
    svg.style.width = `${svgDiameter}px`;
    svg.style.height = `${svgDiameter}px`;
    
    const currentCircumference = 2 * Math.PI * SVG_RING_R;
    ring.style.strokeDasharray = currentCircumference;
    ring.style.strokeDashoffset = (1 - healthPercent) * currentCircumference;

    let ringColor = '#34D399'; 
    if (healthPercent < 0.5) ringColor = '#FBBF24'; 
    if (healthPercent < 0.2) ringColor = '#EF4444'; 
    ring.setAttribute('stroke', ringColor);
  }
  
  // Funktion zur Berechnung der Kosten (zentralisiert)
  function calculateCost(key, level) {
      const up = gameState.upgrades[key];
      if (!up) return 0;

      // NEU: Spezielle Regel f√ºr Floppy Protector (2.5x exponentiell ohne hartes Limit)
      if (key === 'floppyProtector') {
          // Basis: 150 * 2.5 ^ Level
          return Math.floor(up.baseCost * Math.pow(2.5, level));
      }

      // Standard-Logik: Sanfter exponentieller Anstieg f√ºr alle anderen Upgrades
      let costMultiplier = 1.35; 
      
      // St√§rkerer Multiplier f√ºr Produktionsgeb√§ude, um das Balancing zu erh√∂hen
      if (PRODUCTION_BUILDINGS.some(b => b.key === key)) {
          costMultiplier = 1.6; 
      }
      
      // H√∂here Multiplier f√ºr die teuersten Basis-Upgrades
      if (up.baseCost >= 5000) costMultiplier = 1.7; 
      if (up.baseCost >= 75000) costMultiplier = 1.9; 
      
      return Math.floor(up.baseCost * Math.pow(costMultiplier, level));
  }

  function updateUpgradeList() {
    const upgradeList = document.getElementById('upgradeList');
    upgradeList.innerHTML = '';
    
    const upgradeArray = Object.keys(gameState.upgrades).map(key => {
        const up = gameState.upgrades[key];
        const cost = calculateCost(key, up.level);
        // Da Floppy Protector kein echtes Max Level mehr hat (maxLevel: 1000), 
        // wird die Bedingung nun anhand des echten maxLevel gepr√ºft.
        const isMaxLevel = up.maxLevel !== Infinity && up.level >= up.maxLevel;
        return { key, up, cost, isMaxLevel };
    });
    
    upgradeArray.sort((a, b) => {
        // Sortiere Max Level Upgrades ans Ende
        if (a.isMaxLevel && !b.isMaxLevel) return 1;
        if (!a.isMaxLevel && b.isMaxLevel) return -1;
        // Sortiere nach Kosten
        return a.cost - b.cost;
    });

    upgradeArray.forEach(({ key, up, cost, isMaxLevel }) => {
      const canAfford = gameState.data >= cost;
      const title = (up.desc_short || key).replace(/([A-Z])/g, ' $1').trim();

      const upgradeHtml = `
        <div class="flex items-center justify-between liquid-glass p-3 border border-gray-700 rounded-lg">
          <div>
            <div class="text-lg font-bold text-indigo-200 capitalize">${title} (Lv. ${up.level})</div>
            <div class="text-sm ${isMaxLevel ? 'text-green-400' : 'text-yellow-300'}">${isMaxLevel ? 'MAX' : cost.toLocaleString() + ' üíø'}</div>
          </div>
          <div class="flex items-center space-x-2">
            <button data-key="${key}" class="info-btn text-blue-300 hover:text-white transition-colors text-2xl">‚ìò</button>
            <button data-key="${key}" data-cost="${cost}" class="buy-btn p-2 rounded-lg transition-colors font-bold ${canAfford && !isMaxLevel ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-500 cursor-not-allowed'}" ${canAfford && !isMaxLevel ? '' : 'disabled'}>
              Kaufen
            </button>
          </div>
        </div>
      `;
      upgradeList.innerHTML += upgradeHtml;
    });

    // Event-Listener m√ºssen nach dem Einf√ºgen des HTMLs neu zugewiesen werden.
    document.querySelectorAll('.buy-btn').forEach(button => { 
        button.addEventListener('click', handleBuyUpgrade); 
    });
    document.querySelectorAll('.info-btn').forEach(button => { 
        button.addEventListener('click', handleShowInfo); 
    });
  }

  function updateUI() {
    document.getElementById('dataCount').textContent = Math.floor(gameState.data).toLocaleString();
    document.getElementById('viewsCount').textContent = gameState.views.toLocaleString();
    document.getElementById('videoTitle').textContent = gameState.lastVideoTitle;
    document.getElementById('videoBar').style.width = `${gameState.videoProgress}%`;
    document.getElementById('currentBugs').textContent = bugs.length;
    document.getElementById('maxBugs').textContent = gameState.maxBugs;
    // FIX: Die Produktionsrate wird korrekt berechnet und angezeigt
    document.getElementById('prodRate').textContent = Math.floor(calculateProductionRate()).toLocaleString(); 
    
    const ringReferenceSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--player-actual-size'));
    updateHealthRing(ringReferenceSize);
  }
  
  // --- BUG & GAME LOGIC ---

  function calculateBugHP() {
    const baseHP = Math.floor(1 + Math.pow(gameState.videoLevel, 1.3) * 0.5);
    return Math.max(1, baseHP);
  }

  function spawnBug() {
    // Max Bugs wird nur durch videoLevel gesteuert
    gameState.maxBugs = Math.floor(5 + gameState.videoLevel * 1.5); 

    if (bugs.length >= gameState.maxBugs) return;

    const side = Math.floor(Math.random() * 4); 
    let x, y, size, type, damage, speed, maxHP;
    
    const bugType = Math.random();
    const SPEED_MULTIPLIER = 0.3; 
    const baseHP = calculateBugHP(); 
    
    if (bugType < 0.1) { 
      type = 'large'; size = 25; damage = 10 + gameState.videoLevel;
      speed = (0.5 + gameState.videoLevel * 0.05) * SPEED_MULTIPLIER;
      maxHP = baseHP * 3;
    } else if (bugType < 0.2) { 
      type = 'small'; size = 10; damage = 1 + gameState.videoLevel * 0.2;
      speed = (3 + gameState.videoLevel * 0.1) * SPEED_MULTIPLIER;
      maxHP = baseHP * 0.5;
    } else { 
      type = 'normal'; size = 15; damage = 5 + gameState.videoLevel * 0.5;
      speed = (1 + gameState.videoLevel * 0.08) * SPEED_MULTIPLIER;
      maxHP = baseHP;
    }
    
    maxHP = Math.max(1, Math.floor(maxHP)); 

    if (side === 0) { x = Math.random() * CANVAS.width; y = -size; }
    else if (side === 1) { x = CANVAS.width + size; y = Math.random() * CANVAS.height; }
    else if (side === 2) { x = Math.random() * CANVAS.width; y = CANVAS.height + size; }
    else { x = -size; y = Math.random() * CANVAS.height; }

    bugs.push({
      x, y, size, speed, damage, maxHP, currentHP: maxHP, type, 
      emoji: BUG_EMOJIS[Math.floor(Math.random() * BUG_EMOJIS.length)],
      angle: 0
    });
  }
  
  function getProjectileDamage() {
      // FIX: attackDamage wird jetzt korrekt abgefragt
      const damageUpgrade = gameState.upgrades.attackDamage.effect ? gameState.upgrades.attackDamage.effect(gameState.upgrades.attackDamage.level) : 1;
      return damageUpgrade; // Lv 0 = 1 Schaden, Lv 1 = 2 Schaden, etc.
  }

  function fireProjectile(startX, startY, targetX, targetY) {
    const angle = Math.atan2(targetY - startY, targetX - startX);
    const damage = getProjectileDamage(); // Hole den aktuellen Schaden
    projectiles.push({ x: startX, y: startY, speed: 15, angle: angle, damage: damage });
    playSound(440, 0.05, 'square', 0.5); 
  }
  
  // FIX: Erweitert um isGolden Flag f√ºr Gold CD Drops
  function createDataDrop(x, y, value, isGolden = false) {
    const isGold = isGolden || value > 200; 
    for(let i = 0; i < (isGold ? 5 : 1); i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 1.5) * 4,
            life: 20, 
            emoji: isGold ? 'üìÄ' : 'üíø',
            value: value / (isGold ? 5 : 1)
        });
    }
    playSound(isGold ? 880 : 660, 0.1, 'sine', 0.7); 
  }

  function takeDamage(damage) {
    gameState.playerHP -= damage;
    const container = document.getElementById('gameContainer');
    container.classList.add('camera-shake');
    setTimeout(() => { container.classList.remove('camera-shake'); }, 150); 
    playSound(100, 0.1, 'sawtooth', 0.8); 
  }

  function publishVideo() {
    gameState.videoLevel++;
    let newViews = Math.floor(10 * (1 + gameState.videoLevel * 0.1) * (gameState.videoLevel + 1));
    const viewBoost = gameState.upgrades.viewBoost.effect ? gameState.upgrades.viewBoost.effect(gameState.upgrades.viewBoost.level) : 1;
    newViews = Math.floor(newViews * viewBoost);
    gameState.views += newViews;
    
    // Max Bugs neu berechnen (wird nur durch videoLevel gesteuert)
    gameState.maxBugs = Math.floor(5 + gameState.videoLevel * 1.5);
    
    const park = PARK_NAMES[Math.floor(Math.random() * PARK_NAMES.length)];
    const template = VIDEO_TITLES[Math.floor(Math.random() * VIDEO_TITLES.length)];
    gameState.lastVideoTitle = template.replace('(park)', park).replace(' in', ` in ${park}`).replace(' vs.', ` ${park} vs.`).replace('After Hour', `After Hour ${park}`);
    
    playSound(1200, 0.2, 'sine', 0.8); 
  }

  // --- RENDERING FUNKTIONEN (Canvas) ---

  function drawBug(bug) {
    CTX.save();
    CTX.translate(bug.x, bug.y);
    
    CTX.font = `${bug.size * 2}px sans-serif`;
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.fillText(bug.emoji, 0, 0);
    
    if (bug.currentHP < bug.maxHP) {
        const barWidth = bug.size * 2;
        const barHeight = 4;
        const yOffset = -bug.size - 5;
        const healthRatio = bug.currentHP / bug.maxHP;
        
        CTX.fillStyle = '#333';
        CTX.fillRect(-barWidth / 2, yOffset, barWidth, barHeight);
        
        let barColor = '#34D399';
        if (healthRatio < 0.5) barColor = '#FBBF24';
        if (healthRatio < 0.2) barColor = '#EF4444';
        
        CTX.fillStyle = barColor;
        CTX.fillRect(-barWidth / 2, yOffset, barWidth * healthRatio, barHeight);
    }
    CTX.restore();
  }

  function drawProjectile(p) {
    CTX.fillStyle = '#fef08a'; 
    CTX.beginPath();
    CTX.arc(p.x, p.y, 4, 0, Math.PI * 2);
    CTX.fill();
  }

  function drawParticle(p) {
    CTX.save();
    CTX.translate(p.x, p.y);
    CTX.font = `20px sans-serif`;
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.fillText(p.emoji, 0, 0);
    CTX.restore();
  }
  
  // NEU: Zeichnet die Floppy Protector Drohnen, die den Spieler umkreisen
  function drawProtectors() {
    const level = gameState.upgrades.floppyProtector.level;
    if (level === 0) return;
    
    const orbitRadius = 80;
    const protectorSize = 20; 
    
    // Berechne die Rotation basierend auf der Spielzeit
    const timeFactor = gameState.gameTime / 15000; 

    for (let i = 0; i < level; i++) {
        // Gleichm√§ssige Verteilung + Rotation √ºber die Zeit
        const baseAngle = (i / level) * Math.PI * 2;
        const totalAngle = baseAngle + timeFactor * Math.PI * 2; 

        const x = PLAYER_POS.x + Math.cos(totalAngle) * orbitRadius;
        const y = PLAYER_POS.y + Math.sin(totalAngle) * orbitRadius;

        CTX.save();
        CTX.translate(x, y);
        CTX.font = `${protectorSize}px sans-serif`;
        CTX.textAlign = 'center';
        CTX.textBaseline = 'middle';
        // Floppy Disk Emoji
        CTX.fillText('üíæ', 0, 0); 
        CTX.restore();
    }
  }

  // VERBESSERT: Zeichnet die Produktionsgeb√§ude mit visuellem Puls-Effekt
  function drawBuildings() {
    const activeBuildings = PRODUCTION_BUILDINGS.filter(b => gameState.upgrades[b.key]?.level > 0);
    if (activeBuildings.length === 0) return;

    const padding = 30;
    const size = 60; // Gr√∂√üe des Platzes pro Geb√§ude
    const spacing = 10; // Abstand zwischen den Geb√§uden
    const totalWidth = activeBuildings.length * (size + spacing) - spacing;
    const startX = CANVAS.width / 2 - totalWidth / 2 + size / 2; 
    const pulseFactor = Math.sin(gameState.gameTime / 150) * 0.05 + 1; // Leichter Puls

    activeBuildings.forEach((building, index) => {
        const up = gameState.upgrades[building.key];
        
        if (up && up.level > 0 && typeof up.effect === 'function') { 
            const x = startX + (index * (size + spacing));
            const y = CANVAS.height - padding - 25;
            
            CTX.save();
            CTX.translate(x, y);
            
            // 1. Hintergrund-Glow (Pulsing Effect)
            const glowRadius = 35 * pulseFactor;
            CTX.shadowBlur = 15;
            CTX.shadowColor = building.color;
            CTX.fillStyle = 'rgba(255, 255, 255, 0.1)';
            CTX.beginPath();
            CTX.arc(0, 0, glowRadius, 0, Math.PI * 2);
            CTX.fill();
            CTX.shadowBlur = 0; // Schatten zur√ºcksetzen

            // 2. Emoji/Geb√§ude
            CTX.font = '36px sans-serif'; 
            CTX.textAlign = 'center';
            CTX.textBaseline = 'middle';
            CTX.fillStyle = '#fff'; 
            CTX.fillText(building.emoji, 0, 0);
            
            // 3. Produktion pro Sekunde
            CTX.font = '12px Chakra Petch';
            CTX.fillStyle = building.color;
            const prodPerSec = up.effect(up.level).toFixed(0);
            CTX.fillText(`+${prodPerSec} üíø/s`, 0, 28); 
            
            // 4. Level Anzeige
            CTX.font = '10px Chakra Petch';
            CTX.fillStyle = '#bbb';
            CTX.fillText(`Lv. ${up.level}`, 0, -25);
            
            CTX.restore();
        }
    });
  }

  // --- GAME LOOP LOGIC ---

  function updateObjects(deltaTime, collisionRadius) {
    // 1. HP Regeneration
    const regen = gameState.upgrades.hpRegen.effect ? gameState.upgrades.hpRegen.effect(gameState.upgrades.hpRegen.level) / 1000 * deltaTime : 0;
    gameState.playerHP = Math.min(gameState.maxPlayerHP, gameState.playerHP + regen);

    // 2. Bug-Bewegung und Kollision
    bugs = bugs.filter(bug => {
      const dx = PLAYER_POS.x - bug.x;
      const dy = PLAYER_POS.y - bug.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      bug.x += Math.cos(angle) * bug.speed;
      bug.y += Math.sin(angle) * bug.speed;
      
      if (dist < collisionRadius + bug.size / 2) { 
        takeDamage(bug.damage);
        return false; 
      }
      return true;
    });

    // 3. Projektil-Bewegung und Kollision
    projectiles = projectiles.filter(p => {
      p.x += Math.cos(p.angle) * p.speed;
      p.y += Math.sin(p.angle) * p.speed;
      
      if (p.x < 0 || p.x > CANVAS.width || p.y < 0 || p.y > CANVAS.height) { return false; }
      
      let hitBug = false;
      bugs = bugs.filter(bug => {
        const dist = Math.sqrt(Math.pow(p.x - bug.x, 2) + Math.pow(p.y - bug.y, 2));
        if (dist < bug.size) {
          bug.currentHP -= p.damage;
          if (bug.currentHP <= 0) {
            // FIX: moreData Multiplier wird korrekt verwendet (L+1)
            const dataMultiplier = gameState.upgrades.moreData.effect ? gameState.upgrades.moreData.effect(gameState.upgrades.moreData.level) : 1; 
            
            // FIX: Angepasste Basiswerte f√ºr sp√ºrbar mehr Daten
            const baseValue = (bug.type === 'large' ? 80 : (bug.type === 'small' ? 5 : 20)); // Normaler Bug droppt 20
            
            let totalDataValue = baseValue * dataMultiplier;
            let isGolden = false;
            
            // NEUE LOGIK: Golden Drop Chance
            const goldenChance = gameState.upgrades.goldenDropChance.effect ? gameState.upgrades.goldenDropChance.effect(gameState.upgrades.goldenDropChance.level) : 0;
            if (Math.random() < goldenChance) {
                totalDataValue *= 10; // 10x Multiplikator f√ºr Gold CDs
                isGolden = true;
            }
            
            gameState.data += totalDataValue;
            createDataDrop(bug.x, bug.y, totalDataValue, isGolden);
            return false;
          }
          hitBug = true;
          return true;
        }
        return true;
      });
      return !hitBug; 
    });

    // 4. Partikel/Drops
    particles = particles.filter(p => {
        p.vy += 0.2; 
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        const dist = Math.sqrt(Math.pow(p.x - PLAYER_POS.x, 2) + Math.pow(p.y - PLAYER_POS.y, 2));
        if (dist < collisionRadius) {
            playSound(1000, 0.03, 'sine', 0.5); 
            gameState.data += p.value; 
            return false;
        }
        return p.life > 0;
    });
  }

  // NEU: Logik f√ºr den Floppy Protector
  function updateProtectors(deltaTime) {
    const protectorLevel = gameState.upgrades.floppyProtector.level;
    if (protectorLevel === 0) return;
    
    gameState.cooldowns.protectorShot -= deltaTime;

    if (gameState.cooldowns.protectorShot <= 0) {
        if (bugs.length > 0) {
            // Finde den n√§chsten Bug als Ziel
            let targetBug = bugs.reduce((closest, bug) => {
                const dist = Math.sqrt(Math.pow(bug.x - PLAYER_POS.x, 2) + Math.pow(bug.y - PLAYER_POS.y, 2));
                if (!closest || dist < closest.dist) {
                    return { bug, dist };
                }
                return closest;
            }, null)?.bug;

            if (targetBug) {
                // Feuere eine Kugel pro Protector-Level (Drohne)
                for(let i = 0; i < protectorLevel; i++) {
                    // Leichter Streueffekt f√ºr die Optik
                    const angleOffset = (Math.random() - 0.5) * 0.2; 
                    const targetX = targetBug.x + Math.cos(targetBug.angle) * angleOffset * 10;
                    const targetY = targetBug.y + Math.sin(targetBug.angle) * angleOffset * 10;

                    // Projektile werden vom Player-Zentrum gefeuert
                    fireProjectile(PLAYER_POS.x, PLAYER_POS.y, targetX, targetY); 
                }
                playSound(1600, 0.04, 'sine', 0.3);
            }
        }
        gameState.cooldowns.protectorShot = 5000; // 5 Sekunden Cooldown
    }
  }


  function updateBugSpawn(deltaTime) {
      const minSpawnInterval = 500; 
      const baseInterval = 3000;
      const intervalDecrease = gameState.videoLevel * 50; 
      gameState.bugSpawnInterval = Math.max(minSpawnInterval, baseInterval - intervalDecrease);

      if (gameState.gameTime - gameState.lastBugSpawnTime >= gameState.bugSpawnInterval) {
          if (bugs.length < gameState.maxBugs) {
              // Spawn 1 to 3 bugs randomly, but respect maxBugs limit
              const numToSpawn = Math.min(
                  Math.floor(Math.random() * 3) + 1, 
                  gameState.maxBugs - bugs.length
              );
              for(let i = 0; i < numToSpawn; i++) {
                  spawnBug();
              }
          }
          gameState.lastBugSpawnTime = gameState.gameTime;
      }
  }

  function updateProduction(deltaTime) {
    gameState.gameTime += deltaTime;

    // 1. Production Income
    if (gameState.gameTime - gameState.lastProductionTime >= 1000) {
        let totalIncome = 0;
        PRODUCTION_BUILDINGS.forEach(building => {
            const up = gameState.upgrades[building.key];
            // FIX: √úberpr√ºfen, ob die Funktion existiert, um den Fehler zu vermeiden
            if (up && up.level > 0 && typeof up.effect === 'function') {
                const income = up.effect(up.level);
                totalIncome += income;
                // FIX: Animation wird jetzt korrekt getriggert
                createProductionAnimation(building.key, income); 
            }
        });
        gameState.data += totalIncome;
        gameState.lastProductionTime = gameState.gameTime;
        if (totalIncome > 0) { playSound(950, 0.03, 'sine', 0.4); }
    }

    // 2. Video Progress
    // Basis Progress Rate von 1.0 (50s Videozeit)
    const baseProgressRate = 1.0 + gameState.videoLevel * 0.1; 
    // ProdSpeed Multiplier wird korrekt verwendet (geht bis zu 25x = 4s Video)
    const prodSpeedMultiplier = gameState.upgrades.prodSpeed.effect ? gameState.upgrades.prodSpeed.effect(gameState.upgrades.prodSpeed.level) : 1; 
    const finalProgressRate = baseProgressRate * prodSpeedMultiplier;

    gameState.videoProgress = Math.min(100, gameState.videoProgress + finalProgressRate * deltaTime / 1000);

    if (gameState.videoProgress >= 100) {
      publishVideo();
      gameState.videoProgress = 0;
    }

    gameState.cooldowns.shot = Math.max(0, gameState.cooldowns.shot - deltaTime / 1000);

    if (gameState.playerHP <= 0 && !isGameOver) {
      isGameOver = true;
      showGameOver();
      playSound(50, 1, 'sawtooth', 1.0); 
    }
    
    // 3. Produktions-Animationen updaten
    productionAnimations = productionAnimations.filter(anim => {
        anim.y += anim.vy; anim.x += anim.vx; anim.life--;
        const el = document.getElementById(`prod-anim-${anim.id}`);
        if (el) { el.style.top = `${anim.y}px`; el.style.left = `${anim.x}px`; el.style.opacity = anim.life / 60; }
        if (anim.life <= 0) { if (el) el.remove(); return false; }
        return true;
    });

    // 4. Protector Logic
    updateProtectors(deltaTime);
  }

  function gameLoop(timestamp) {
    if (!window.gameLoopRunning) return;

    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (!isGamePaused && !isGameOver) {
      CTX.clearRect(0, 0, CANVAS.width, CANVAS.height); 
      
      const ringReferenceSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--player-actual-size'));
      const collisionRadius = getPlayerCollisionRadius(ringReferenceSize);

      updateProduction(deltaTime); 
      updateBugSpawn(deltaTime); 
      updateObjects(deltaTime, collisionRadius);
      
      bugs.forEach(drawBug);
      projectiles.forEach(drawProjectile);
      particles.forEach(drawParticle);
      
      drawBuildings(); // NEU: Die Geb√§ude werden jetzt mit Puls-Effekt korrekt gezeichnet
      drawProtectors(); // NEU: Die Floppy Protector Drohnen werden gezeichnet
    }
    
    updateUI();
    saveGameState();
    frameCount++;
    requestAnimationFrame(gameLoop);
  }

  // --- INPUT / MODALS ---

  // Globale Funktion f√ºr den Kauf-Button
  function handleBuyUpgrade(e) {
    const key = e.currentTarget.dataset.key;
    const up = gameState.upgrades[key];
    
    // Die Pr√ºfung auf Max Level basiert jetzt auf dem definierten (hohen) maxLevel
    if (up.maxLevel !== Infinity && up.level >= up.maxLevel) return; 

    const cost = calculateCost(key, up.level); 

    if (gameState.data >= cost) {
      gameState.data -= cost;
      up.level++;
      updateUI(); // UI updaten (inklusive Kosten und Daten-Anzeige)
      updateUpgradeList(); // Shop-Liste sofort aktualisieren, um Button-Zust√§nde zu √§ndern
      playSound(700, 0.05, 'triangle', 0.6); 
    } else {
      const title = (up.desc_short || key).replace(/([A-Z])/g, ' $1').trim();
      showInfo('Fehler', `Du ben√∂tigst ${cost.toLocaleString()} Daten (üíø) um das Upgrade "${title}" zu kaufen.`);
      playSound(200, 0.1, 'sawtooth', 0.7); 
    }
  }
  
  // Globale Funktion f√ºr den Info-Button
  function handleShowInfo(e) {
    const key = e.currentTarget.dataset.key;
    const up = gameState.upgrades[key];
    const title = (up.desc_short || key).replace(/([A-Z])/g, ' $1').trim();
    
    const cost = calculateCost(key, up.level);
    
    let info = up.desc; 

    if (up.effect) {
        // Allgemeine Effekte
        const currentEffect = up.effect(up.level);
        
        let currentEffectText = currentEffect;

        if (key === 'prodSpeed') {
            const baseVideoTime = 100 / (1.0 + gameState.videoLevel * 0.1); // Zeit in s bei 1x
            const currentVideoTime = Math.floor(baseVideoTime / currentEffect);
            currentEffectText = `(x${currentEffect.toFixed(2)} Multiplier. Videozeit: ca. ${currentVideoTime}s)`;
        } else if (key === 'goldenDropChance') {
            currentEffectText = `${(Math.min(1.0, currentEffect) * 100).toFixed(1)}% Chance`;
        } else if (key === 'moreData') {
             // FIX: Korrekte Anzeige des Drop-Multiplikators und der Basiswerte
             const dataDropBase = 20; // Normaler Bug Drop
             currentEffectText = `x${currentEffect.toFixed(1)} Daten-Multiplikator. Normaler Bug droppt ${Math.floor(dataDropBase * currentEffect).toLocaleString()} üíø.`;
        } else if (key === 'attackDamage') {
             currentEffectText = `${currentEffect.toFixed(0)} Schaden pro Schuss`;
        } else if (PRODUCTION_BUILDINGS.some(b => b.key === key)) {
            currentEffectText = `Generiert ${currentEffect.toLocaleString()} üíø/s`;
        } else if (key === 'hpRegen') {
             currentEffectText = `${currentEffect.toFixed(2)} HP/s Regeneration`;
        } else if (key === 'attackSpeed') {
             currentEffectText = `${currentEffect.toFixed(3)} Sekunden Cooldown f√ºr manuellen Schuss`;
        } else if (key === 'floppyProtector') {
             currentEffectText = `${currentEffect.toFixed(0)} Drohnen aktiv. Feuern alle 5s.`;
        }

        info += ` Aktueller Effekt (Lv. ${up.level}): ${currentEffectText}.`;

        if (up.maxLevel === Infinity || up.level < up.maxLevel) {
            const nextEffect = up.effect(up.level + 1);
            const nextCost = calculateCost(key, up.level + 1);
            let nextEffectText = nextEffect;

            if (key === 'prodSpeed') {
                const baseVideoTime = 100 / (1.0 + gameState.videoLevel * 0.1);
                const nextVideoTime = Math.floor(baseVideoTime / nextEffect);
                nextEffectText = `(x${nextEffect.toFixed(2)} Multiplier. Videozeit: ca. ${nextVideoTime}s)`;
            } else if (key === 'goldenDropChance') {
                nextEffectText = `${(Math.min(1.0, nextEffect) * 100).toFixed(1)}% Chance`;
            } else if (key === 'moreData') {
                 const dataDropBase = 20;
                 nextEffectText = `x${nextEffect.toFixed(1)} Daten-Multiplikator. Normaler Bug droppt ${Math.floor(dataDropBase * nextEffect).toLocaleString()} üíø.`;
            } else if (key === 'attackDamage') {
                 nextEffectText = `${nextEffect.toFixed(0)} Schaden pro Schuss`;
            } else if (PRODUCTION_BUILDINGS.some(b => b.key === key)) {
                nextEffectText = `Generiert ${nextEffect.toLocaleString()} üíø/s`;
            } else if (key === 'hpRegen') {
                nextEffectText = `${nextEffect.toFixed(2)} HP/s Regeneration`;
            } else if (key === 'attackSpeed') {
                 nextEffectText = `${nextEffect.toFixed(3)} Sekunden Cooldown f√ºr manuellen Schuss`;
            } else if (key === 'floppyProtector') {
                 nextEffectText = `${nextEffect.toFixed(0) + 1} Drohnen aktiv.`; // Zeigt an, dass eine weitere Drohne hinzukommt
            }
            
            info += ` N√§chstes Level (${up.level + 1}): Effekt ${nextEffectText}.`;
            // Wenn das n√§chste Level unter dem Max-Level liegt (oder das Max-Level sehr hoch ist)
            if (up.level < up.maxLevel) { 
                info += ` Kosten: ${nextCost.toLocaleString()} üíø.`;
            } else {
                 info += ` Kosten: ${cost.toLocaleString()} üíø.`; // Zeigt die aktuellen Kosten
            }
        } else if (up.maxLevel && up.level >= up.maxLevel) {
            info += ` **MAXIMALES LEVEL ERREICHT.**`;
        }
    } else {
        info += ` Aktuelles Level: ${up.level}.`;
        if (up.maxLevel && up.level < up.maxLevel) {
            info += ` N√§chstes Upgrade (${up.level + 1}): Kosten ${cost.toLocaleString()} üíø.`;
        } else if (up.maxLevel && up.level >= up.maxLevel) {
            info += ` **MAXIMALES LEVEL ERREICHT.**`;
        }
    }
    
    showInfo(title, info);
  }

  function shootPlayer(targetX, targetY) {
      const multishotCount = gameState.upgrades.multiShot.effect ? gameState.upgrades.multiShot.effect(gameState.upgrades.multiShot.level) : 1;
      const spreadAngle = multishotCount > 1 ? Math.PI / 18 : 0; 
      // FIX: attackSpeed aus dem Upgrade holen
      const attackSpeed = gameState.upgrades.attackSpeed.effect ? gameState.upgrades.attackSpeed.effect(gameState.upgrades.attackSpeed.level) : 0.5;

      if (gameState.cooldowns.shot > 0) return; 

      for(let i = 0; i < multishotCount; i++) {
        const baseAngle = Math.atan2(targetY - PLAYER_POS.y, targetX - PLAYER_POS.x);
        const offsetAngle = (i - (multishotCount - 1) / 2) * spreadAngle;
        const finalAngle = baseAngle + offsetAngle;
        
        // FIX: fireProjectile ohne Schaden-Parameter aufrufen, da es im inneren Damage holt
        fireProjectile(PLAYER_POS.x, PLAYER_POS.y, PLAYER_POS.x + Math.cos(finalAngle) * 100, PLAYER_POS.y + Math.sin(finalAngle) * 100);
      }
      gameState.cooldowns.shot = attackSpeed; 
      playSound(1500, 0.05, 'triangle', 0.5);
  }
  
  function handleCanvasClick(event) {
    if (isGamePaused || isGameOver) return;
    const rect = CANVAS.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;
    if (gameState.cooldowns.shot <= 0) { shootPlayer(clickX, clickY); }
  }

  function showModal(modalId) {
    isGamePaused = true;
    document.getElementById('modalOverlay').classList.remove('hidden');
    document.getElementById('shopModal').classList.add('hidden');
    document.getElementById('settingsModal').classList.add('hidden');
    document.getElementById('infoPopup').classList.add('hidden');
    document.getElementById('gameOverModal').classList.add('hidden');
    document.getElementById(modalId).classList.remove('hidden');
    
    // WICHTIG: Shop-Liste nur dann aktualisieren, wenn der Shop ge√∂ffnet wird
    if (modalId === 'shopModal') {
        updateUpgradeList(); 
    }
    updateUI();
  }

  function hideAllModals() {
    document.getElementById('modalOverlay').classList.add('hidden');
    document.getElementById('shopModal').classList.add('hidden');
    document.getElementById('settingsModal').classList.add('hidden');
    document.getElementById('infoPopup').classList.add('hidden');
    isGamePaused = false;
  }
  
  function showInfo(title, text) {
    document.getElementById('infoTitle').textContent = title;
    document.getElementById('infoText').textContent = text;
    document.getElementById('shopModal').classList.add('hidden');
    document.getElementById('settingsModal').classList.add('hidden');
    showModal('infoPopup');
  }
  
  function showGameOver() {
    isGamePaused = true;
    document.getElementById('finalScore').textContent = gameState.views.toLocaleString();
    showModal('gameOverModal'); 
  }

  async function submitScoreAndReset() {
    const playerName = document.getElementById('playerNameInput').value || 'Anonym';
    const score = gameState.views;
    const embed = {
      title: "Neuer Highscore im Medienspeicher Code Defender!",
      description: `${playerName} hat **${score.toLocaleString()}** Views erzielt.`,
      color: 16766720
    };

    try {
      await fetch(DISCORD_WEBHOOK, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: "Code Defender Bot",
          avatar_url: "https://placehold.co/128x128/3b82f6/FFFFFF?text=üíæ",
          embeds: [embed]
        })
      });
      alertPlaceholder('Score erfolgreich gesendet! Spiel wird zur√ºckgesetzt.', resetGameState);
    } catch (error) {
      console.error("Fehler beim Senden an Discord:", error);
      alertPlaceholder('Fehler beim Senden des Scores. Spiel wird dennoch zur√ºckgesetzt.', resetGameState);
    }
  }
  
  function alertPlaceholder(message, callback) {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[99]';
      modal.innerHTML = `
        <div class="liquid-glass w-full max-w-xs p-6 text-center">
          <p class="text-white mb-4">${message}</p>
          <button id="alertBtn" class="w-full p-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition-colors font-bold">OK</button>
        </div>
      `;
      document.body.appendChild(modal);
      document.getElementById('alertBtn').onclick = () => {
          modal.remove();
          if(callback) callback();
      };
  }
  
  function createProductionAnimation(buildingKey, amount) {
    const activeBuildings = PRODUCTION_BUILDINGS.filter(b => gameState.upgrades[b.key]?.level > 0);
    const indexInActiveList = activeBuildings.findIndex(b => b.key === buildingKey);

    // Nur Animation, wenn das Geb√§ude existiert
    if (indexInActiveList === -1) return;
    
    const padding = 30;
    const size = 60; // Muss mit drawBuildings √ºbereinstimmen
    const spacing = 10;
    const totalWidth = activeBuildings.length * (size + spacing) - spacing;
    const startX = CANVAS.width / 2 - totalWidth / 2 + size / 2;
    
    // X und Y Position des Geb√§udes
    const x = startX + (indexInActiveList * (size + spacing)); 
    const y = CANVAS.height - padding - 25; 
    
    const animId = Date.now() + Math.random();
    
    const animElement = document.createElement('div');
    animElement.id = `prod-anim-${animId}`;
    animElement.className = 'production-animation';
    // FIX: Die angezeigte Menge ist jetzt die *tats√§chliche* Produktion
    animElement.textContent = `+${Math.floor(amount)}`;
    animElement.style.top = `${y}px`;
    animElement.style.left = `${x}px`;
    
    PRODUCTION_ANIM_CONTAINER.appendChild(animElement);

    productionAnimations.push({
        id: animId, x: x, y: y, value: `+${Math.floor(amount)}`, life: 60,
        // FIX: Leichte zuf√§llige Bewegung nach oben
        vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random() * 2 
    });
  }


  // --- INITIALISIERUNG ---

  function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    CANVAS.width = container.clientWidth;
    CANVAS.height = container.clientHeight;
    
    PLAYER_POS.x = CANVAS.width / 2;
    PLAYER_POS.y = CANVAS.height / 2;
    
    const ringReferenceSize = Math.min(CANVAS.width, CANVAS.height) * PLAYER_SIZE_PERCENTAGE;
    const playerDiv = document.getElementById('player');
    
    const playerVisualSize = ringReferenceSize * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--player-visual-scale'));

    playerDiv.style.fontSize = `${playerVisualSize}px`;
    document.documentElement.style.setProperty('--player-actual-size', `${ringReferenceSize}px`);
    
    updateUI(); 
  }

  function setupEvents() {
    window.addEventListener('resize', resizeCanvas);
    // Button Event Listener f√ºr Shop/Settings
    document.getElementById('shopBtn').addEventListener('click', () => showModal('shopModal'));
    document.getElementById('settingsBtn').addEventListener('click', () => showModal('settingsModal'));
    document.getElementById('closeShopBtn').addEventListener('click', hideAllModals);
    document.getElementById('closeSettingsBtn').addEventListener('click', hideAllModals);
    document.getElementById('closeInfoBtn').addEventListener('click', hideAllModals);
    document.getElementById('submitScoreBtn').addEventListener('click', submitScoreAndReset);
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
        const vol = e.target.value;
        gameState.settings.volume = parseInt(vol);
        masterGain.gain.setValueAtTime(vol / 100, audioContext.currentTime);
        saveGameState();
    });

    CANVAS.addEventListener('mousedown', handleCanvasClick);
    CANVAS.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleCanvasClick(e.touches[0]);
    }, { passive: false });
  }

  window.onload = function () {
    setupEvents();
    resizeCanvas(); 
    loadGameState();
    
    if (!window.gameLoopRunning) {
        window.gameLoopRunning = true;
        requestAnimationFrame(gameLoop);
    }
  }
</script>
</body>
</html>

